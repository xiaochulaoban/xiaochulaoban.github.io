<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="x5-fullscreen" content="true">
<meta name="full-screen" content="yes">
<meta name="theme-color" content="#317EFB" />
<meta content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=0" name="viewport">
<meta name="description" content="面向对象基础01：面向对象和面向过程的区别两者的主要区别在于解决问题的方式  面向过程把解决问题的过程拆分成一个个方法，通过一个个方法的执行解决问题 面向对象会先抽象处对象，然后用对象执行方法的方式解决问题,并且面向对象开发的程序一般更容易维护、容易复用，容易扩展  02:创建一个对象用什么运算符？对象实体与对象引用有何不同？创建对象用new运算符  一个对象引用可以指向0个运算符或1个运算符 一">
<meta property="og:type" content="article">
<meta property="og:title" content="xiaochuhome">
<meta property="og:url" content="http://example.com/2024/01/18/java%E5%9F%BA%E7%A1%802/index.html">
<meta property="og:site_name" content="xiaochuhome">
<meta property="og:description" content="面向对象基础01：面向对象和面向过程的区别两者的主要区别在于解决问题的方式  面向过程把解决问题的过程拆分成一个个方法，通过一个个方法的执行解决问题 面向对象会先抽象处对象，然后用对象执行方法的方式解决问题,并且面向对象开发的程序一般更容易维护、容易复用，容易扩展  02:创建一个对象用什么运算符？对象实体与对象引用有何不同？创建对象用new运算符  一个对象引用可以指向0个运算符或1个运算符 一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="article:published_time" content="2024-01-18T09:37:41.015Z">
<meta property="article:modified_time" content="2024-01-08T02:41:04.943Z">
<meta property="article:author" content="zhenxing Chu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/404.jpg">


<title >xiaochuhome</title>

<!-- Favicon -->

    <link href='/img/favicon.svg?v=2.1.0-beta.2' rel='icon' type='image/png' sizes='16x16' ></link>


    <link href='/img/favicon.svg?v=2.1.0-beta.2' rel='icon' type='image/png' sizes='32x32' ></link>




<!-- Plugin -->




    
<link rel="stylesheet" href="/css/plugins/bootstrap.row.css">

    
<link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.css">

    
    




<!-- Icon -->

    
<link rel="stylesheet" href="/css/plugins/font-awesome.min.css">




<!-- Variable -->
<script>window.ASYNC_CONFIG = {"hostname":"example.com","author":"zhenxing Chu","root":"/","typed_text":null,"theme_version":"2.1.0-beta.2","theme":{"switch":true,"default":"style-light"},"favicon":{"logo":"/img/favicon.svg","icon16":"/img/favicon.svg","icon32":"/img/favicon.svg","appleTouchIcon":null,"webmanifest":null,"visibilitychange":false,"hidden":"/failure.ico","showText":"(/≧▽≦/)Hey! Good again!","hideText":"(●—●)Oh, crash!"},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms","author":"Post author: ","copyright_link":"Post link: ","copyright_license_title":"Copyright Notice: ","copyright_license_content":"All articles in this blog are licensed under undefined unless otherwise stated.","copy_success":"Copied","copy_failure":"Copy failed","open_read_mode":"Enter reading mode","exit_read_mode":"Exit reading mode","notice_outdate_message":"It has been undefined days since the last update, the content of the article may be outdated.","just":"Just","min":"minutes ago","hour":"hours ago","day":"days ago","month":"months ago"},"swup":false,"plugin":{"flickr_justified_gallery":"https://unpkg.com/flickr-justified-gallery@latest/dist/fjGallery.min.js"},"icons":{"sun":"far fa-sun","moon":"far fa-moon","play":"fas fa-play","email":"far fa-envelope","next":"fas fa-arrow-right","calendar":"far fa-calendar-alt","clock":"far fa-clock","user":"far fa-user","back_top":"fas fa-arrow-up","close":"fas fa-times","search":"fas fa-search","reward":"fas fa-hand-holding-usd","user_tag":"fas fa-user-alt","toc_tag":"fas fa-th-list","read":"fas fa-book-reader","arrows":"fas fa-arrows-alt-h","double_arrows":"fas fa-angle-double-down","copy":"fas fa-copy"},"icontype":"font","highlight":{"plugin":"prismjs","theme":true,"copy":true,"lang":true,"title":"default","height_limit":false}};</script>
<script id="async-page-config">window.PAGE_CONFIG = {"isPost":true,"isHome":false,"postUpdate":"2024-01-08 10:41:04"};</script>

<!-- Theme mode css -->
<link data-swup-theme rel="stylesheet" href="/css/index.css?v=2.1.0-beta.2" id="trm-switch-style">
<script>
    let defaultMode = ASYNC_CONFIG.theme.default !=='auto' ?  ASYNC_CONFIG.theme.default : (window.matchMedia("(prefers-color-scheme: light)").matches ? 'style-light' : 'style-dark')
    let catchMode = localStorage.getItem('theme-mode') || defaultMode;
    let type = catchMode === 'style-dark' ? 'add' : 'remove';
    document.documentElement.classList[type]('dark')
</script>

<!-- CDN -->


    
    



<!-- Site Analytics -->
 
<meta name="generator" content="Hexo 7.0.0"></head>

<body>

  <!-- app wrapper -->
  <div class="trm-app-frame">

    <!-- page preloader -->
    <div class="trm-preloader">
    <div class="trm-holder">
        <div class="preloader">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
</div>
    <!-- page preloader end -->

    <!-- change mode preloader -->
    <div class="trm-mode-swich-animation-frame">
    <div class="trm-mode-swich-animation">
        <i class="i-sun"><i class="iconfont far fa-sun"></i></i>
        <div class="trm-horizon"></div>
        <i class="i-moon"><i class="iconfont far fa-moon"></i></i>
    </div>
</div>
    <!-- change mode preloader end -->

      <!-- scroll container -->
      <div id="trm-dynamic-content" class="trm-swup-animation">
        <div id="trm-scroll-container" class="trm-scroll-container" style="opacity: 0">
            <!-- top bar -->
            <header class="trm-top-bar">
	<div class="container">
		<div class="trm-left-side">
			<!-- logo -->
<a href="/" class="trm-logo-frame trm-anima-link">
    
        <img alt="logo" src="/img/favicon.svg">
    
    
        <div class="trm-logo-text">
            huli<span>xiao</span>
        </div>
    
</a>
<!-- logo end -->
		</div>
		<div class="trm-right-side">
			<!-- menu -->
<div class="trm-menu">
    <nav>
        <ul>
            
            <li class="menu-item-has-children ">
                <a  href="/" target="">
                    Home
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/archives/" target="">
                    Archives
                </a>
                
            </li>
            
        </ul>
    </nav>
</div>
<!-- menu end -->
			
    <!-- mode switcher place -->
    <div class="trm-mode-switcher-place">
        <div class="trm-mode-switcher">
            <i class="iconfont far fa-sun"></i>
            <input class="tgl tgl-light" id="trm-swich" type="checkbox">
            <label class="trm-swich" for="trm-swich"></label>
            <i class="iconfont far fa-moon"></i>
        </div>
    </div>
    <!-- mode switcher place end -->

			
		</div>
		<div class="trm-menu-btn">
			<span></span>
		</div>
	</div>
</header>
            <!-- top bar end -->

            <!-- body -->
            
<div class="trm-content-start">
    <!-- banner -->
    <div class="trm-banner">
    
    <!-- banner cover -->
    <img style="object-position:top;object-fit:cover;" alt="banner" class="trm-banner-cover" src="/img/banner.png">
    <!-- banner cover end -->
    

    <!-- banner content -->
    <div class="trm-banner-content trm-overlay">
        <div class="container">
            <div class="row">
                
                <div class="col-lg-4"></div>
                
                <div class="col-lg-8">

                    <!-- banner title -->
                    <div class="trm-banner-text ">
                        <div class="trm-label trm-mb-20">
                            NEWS LETTER
                        </div>
                        <h1 class="trm-mb-30 trm-hsmb-font">
                            
                        </h1>

                        
                            <ul class="trm-breadcrumbs trm-label">
                                <li>
                                    <a href="/" class="trm-anima-link">Home</a>
                                </li>
                                <li>
                                    <span>
                                        2024
                                    </span>
                                </li>
                            </ul>
                        
                    </div>
                    <!-- banner title end -->

                    <!-- scroll hint -->
                    <span id="scroll-triger" class="trm-scroll-hint-frame">
                        <div class="trm-scroll-hint"></div>
                        <span class="trm-label">Scroll down</span>
                    </span>
                    <!-- scroll hint end -->

                </div>
            </div>
        </div>
    </div>
    <!-- banner content end -->
</div>
    <!-- banner end -->
    <div class="container">
        <div class="row">
            
                <div id="page-sidebar" class="col-lg-4 hidden-sm">
                    <!-- main card -->
                    <div class="trm-main-card-frame trm-sidebar">
    <div class="trm-main-card"> 
        <!-- card header -->
<div class="trm-mc-header">
    <div class="trm-avatar-frame trm-mb-20">
        <img alt="Avatar" class="trm-avatar" src="/img/avatar.jpg">
    </div>
    <h5 class="trm-name trm-mb-15">
        小狐狸
    </h5>
    
</div>
<!-- card header end -->
        <!-- sidebar social -->

<div class="trm-divider trm-mb-40 trm-mt-40"></div>
<div class="trm-social">
    
        <a href="https://github.com" title="Github" rel="nofollow" target="_blank">
            <i class="iconfont fab fa-github"></i>
        </a>
    
</div>

<!-- sidebar social end -->
        <!-- info -->
<div class="trm-divider trm-mb-40 trm-mt-40"></div>
<ul class="trm-table trm-mb-20">
    
        <li>
            <div class="trm-label">
                Residence:
            </div>
            <div class="trm-label trm-label-light">
                Mars
            </div>
        </li>
    
</ul>
<!-- info end -->

        
    </div>
</div>
                    <!-- main card end -->
                </div>
            
            <div id="page-content" class="col-lg-8">
                <div class="trm-content" id="trm-content">
                    <div id="post-info" class="row hidden-sm">
    <div class="col-sm-4">
        <div class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-calendar-alt trm-icon"></i><br>
            01/18
        </div>
    </div>
    <div class="col-sm-4">
        <div class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-clock trm-icon"></i><br>
            17:37
        </div>
    </div>
    <div class="col-sm-4">
        <div id="post-author" class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-user trm-icon"></i><br>
            zhenxing Chu
        </div>
    </div>
</div>
<div class="trm-card ">
    <article id="article-container" class="trm-publication">
    <h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="01：面向对象和面向过程的区别"><a href="#01：面向对象和面向过程的区别" class="headerlink" title="01：面向对象和面向过程的区别"></a>01：面向对象和面向过程的区别</h3><p>两者的主要区别在于解决问题的方式</p>
<ul>
<li>面向过程把解决问题的过程拆分成一个个方法，通过一个个方法的执行解决问题</li>
<li>面向对象会先抽象处对象，然后用对象执行方法的方式解决问题,并且面向对象开发的程序一般更容易维护、容易复用，容易扩展</li>
</ul>
<h3 id="02-创建一个对象用什么运算符？对象实体与对象引用有何不同？"><a href="#02-创建一个对象用什么运算符？对象实体与对象引用有何不同？" class="headerlink" title="02:创建一个对象用什么运算符？对象实体与对象引用有何不同？"></a>02:创建一个对象用什么运算符？对象实体与对象引用有何不同？</h3><p>创建对象用new运算符</p>
<ul>
<li>一个对象引用可以指向0个运算符或1个运算符</li>
<li>一个对象也可以有n个引用指向它</li>
</ul>
<h3 id="03：对象的相等和引用的相等的区别"><a href="#03：对象的相等和引用的相等的区别" class="headerlink" title="03：对象的相等和引用的相等的区别"></a>03：对象的相等和引用的相等的区别</h3><ul>
<li>对象的相等一般比较的是内存中存放的内容是否相等</li>
<li>引用的相等一般比较的是他们指向的内存地址是否相等</li>
</ul>
<h3 id="04-如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#04-如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="04:如果一个类没有声明构造方法，该程序能正确执行吗"></a>04:如果一个类没有声明构造方法，该程序能正确执行吗</h3><p>首先：构造方法时一种特殊的方法，主要作用是用于对象的初始化工作。</p>
<p>如果一个类没有声明构造方法，也可以执行，因为一个类即时没有声明构造方法也会有默认的不带参数的构造方法。</p>
<h3 id="05：构造方法有哪些特点？是否可以被Override？"><a href="#05：构造方法有哪些特点？是否可以被Override？" class="headerlink" title="05：构造方法有哪些特点？是否可以被Override？"></a>05：构造方法有哪些特点？是否可以被Override？</h3><p>特点如下：</p>
<ul>
<li>名字与类名相同</li>
<li>没有返回值，但不能使用void声明构造函数</li>
<li>生成类的对象时自动执行，无需调用</li>
</ul>
<p>构造方法不能被override，但是可以被overload，所以一个类中可以看到有多个构造函数的情况。</p>
<h3 id="06：面向对象的三大特征"><a href="#06：面向对象的三大特征" class="headerlink" title="06：面向对象的三大特征"></a>06：面向对象的三大特征</h3><ul>
<li>封装：是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</li>
<li>继承：不同类型的对象，相互之间常有一定数量的共同点。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性的继承父类。通过使用继承，可以快速创建新的类，可以提高代码的重用，程序的可维护性。</li>
</ul>
<p><strong>继承具有如下3个特点</strong>：①子类拥有父类对象所有的属性和方法（包括私有属性和私有方法）,但是父类中的私有属性和方法子类是无法访问，只是拥有，②子类可以拥有自己的属性和方法，即子类可以对父类进行扩展③子类可以用自己的方式实现父类的方法</p>
<ul>
<li><p>多态：表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<p><strong>多态的特点</strong>：①对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系②引用类型变量发出的方法调用到底是哪个类中的方法，必须在程序运行期间才能确定。③多态不能调用&#x3D;&#x3D;只在子类存在但在父类不存在&#x3D;&#x3D;的方法④如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="07：接口和抽象类有什么共同点和区别"><a href="#07：接口和抽象类有什么共同点和区别" class="headerlink" title="07：接口和抽象类有什么共同点和区别"></a>07：接口和抽象类有什么共同点和区别</h3><p>共同点：①都不能被实例化②都可以包含抽象方法③都可以有默认实现的方法（Java 8可以用default关键字在接口中定义默认方法）</p>
<p>区别：①接口主要用于对类的行为进行约束，你实现了某个接口具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。②一个类只能继承一个抽抽象类，但可以实现多个抽象接口。③接口中的成员变量只能是&#x3D;&#x3D;public static final&#x3D;&#x3D;类型的，不能被修改，且必须具有初始值，而抽象类的成员变量默认是default，可在子类中别重新定义，也可以被重新赋值。</p>
<h3 id="08-深拷贝和浅拷贝的区别？什么是引用拷贝"><a href="#08-深拷贝和浅拷贝的区别？什么是引用拷贝" class="headerlink" title="08:深拷贝和浅拷贝的区别？什么是引用拷贝"></a>08:深拷贝和浅拷贝的区别？什么是引用拷贝</h3><ul>
<li>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说，拷贝对象和原对象公用一个内部对象。</li>
<li>深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>
<li>引用拷贝：引用拷贝就是两个不同的引用指向同一个对象。</li>
</ul>
<p><img src="C:\Users\Acer\AppData\Roaming\Typora\typora-user-images\image-20240106155324688.png" alt="image-20240106155324688" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="09-Object类常见方法有哪些"><a href="#09-Object类常见方法有哪些" class="headerlink" title="09:Object类常见方法有哪些"></a>09:Object类常见方法有哪些</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="10-和equals的区别"><a href="#10-和equals的区别" class="headerlink" title="10:&#x3D;&#x3D;和equals的区别"></a>10:&#x3D;&#x3D;和equals的区别</h3><p>**&#x3D;&#x3D;**：对于基本数据类型和引用数据类型的效果是不同的：</p>
<ul>
<li><p>对于基本数据类型来说：**&#x3D;&#x3D;**比较的是值</p>
</li>
<li><p>对于引用数据类型来说：**&#x3D;&#x3D;**比较的是对象的内存地址</p>
</li>
</ul>
<p><strong>因为Java只有值传递，所以对于&#x3D;&#x3D;来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存在的值是对象的地址</strong></p>
<p><strong>equals()</strong>:不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals（）方法存在于Object类中，而Object类是所有类的直接类或间接类，因此所有的类都有equals（）方法</p>
<p><strong>Object类中equals（）方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>equals()方法存在两种使用情况</strong></p>
<ul>
<li><strong>类没有重写equals()方法：</strong>通过equals()比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的是默认Object类equals()方法</li>
<li>类重写了equals()方法：一般我们都重写equals()方法来比价两个对象中的属性是否相等；若他们的属性相等，则返回true(认为这两个对象相同)</li>
</ul>
<h3 id="11-hashCode-有什么用？"><a href="#11-hashCode-有什么用？" class="headerlink" title="11:hashCode()有什么用？"></a>11:hashCode()有什么用？</h3><p><strong>hashcode()</strong>:hashcode（）的作用是获得哈希码（int 整数）,也称散列码。这个哈希码的作用是确定该对象在哈希表中索引位置。</p>
<p><img src="C:\Users\Acer\AppData\Roaming\Typora\typora-user-images\image-20240107095125223.png" alt="image-20240107095125223" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="12：为什么要有hashCode？"><a href="#12：为什么要有hashCode？" class="headerlink" title="12：为什么要有hashCode？"></a>12：为什么要有hashCode？</h3><ul>
<li>以HashSet为例，hashCode在HashSet中用于计算对象加入的位置，当加入一个对象时，HashSet首先会计算该对象的hash值，然后检查已经加入对象的hashCode值是否与当前对象的hashCode相同，如果没有相符的hashCode的话，则HashSet假设加入的对象没有重复出现，如果相同的话，通过equals()方法来进一步比较，判断内容是否相同。如果不同的话，就会重新散列（&#x3D;&#x3D;散列表存储的是键值对&#x3D;&#x3D;）到其他位置，这样就大大减少了equals的次数，相应的提高了执行速度，缩小了查找成本。</li>
</ul>
<p><strong>为什么不只提供hashCode()方法呢？</strong>因为两个对象的hashCode值相等并不代表两个对象就相等。</p>
<p><strong>为什么两个对象有相同的hashCode值，他们也不一定是相等的？</strong></p>
<ul>
<li>如果两个对象的hashCode值相等，那这两个对象不一定相等（哈希碰撞）</li>
<li>如果两个对象的hashCode值相等，并且equals()方法也返回True,才认为这两个对象相等</li>
<li>如果两个对象的hash值不相等，我们就可以直接认为这两个对象不相等</li>
</ul>
<p><strong>为什么重写equals()时必须重写hashCode方法？</strong></p>
<ul>
<li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>
<li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li>
</ul>
<h3 id="13-解决哈希碰撞有哪些常见的方法"><a href="#13-解决哈希碰撞有哪些常见的方法" class="headerlink" title="13:解决哈希碰撞有哪些常见的方法"></a>13:解决哈希碰撞有哪些常见的方法</h3><ul>
<li><p>开放地址法：当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。</p>
<p>Hi&#x3D;(H(key)+di) MOD m i&#x3D;1,2,…,k(k&lt;&#x3D;m-1)，其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。如果di取1，则每次冲突之后，向后移动1个位置。还有二次探测再散列</p>
</li>
<li><p>再哈希法：当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突,缺点是增加了计算时间</p>
</li>
<li><p>拉链法：将所有哈希地址为&#x3D;&#x3D;i&#x3D;&#x3D;的元素构成一个单链表，将单链表的头指针存在哈希表的第i个单元中</p>
</li>
<li><p>建立一个公共溢出区：假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设立存储空间向量OverTable[0..v]用以存储发生冲突的记录</p>
</li>
</ul>
<h3 id="14-String、StringBuffer、StringBuilder的区别"><a href="#14-String、StringBuffer、StringBuilder的区别" class="headerlink" title="14:String、StringBuffer、StringBuilder的区别"></a>14:String、StringBuffer、StringBuilder的区别</h3><p><strong>可变性</strong></p>
<ul>
<li>String是不可变的</li>
<li>StringBuilder和StringBuffer都继承与AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，不过没有使用final和private关键字修饰，所以StringBuilder和StringBuffer都是可变的</li>
</ul>
<p><strong>线程安全性</strong></p>
<ul>
<li>Stirng中的对象是不可变的，也就可以理解为常量，线程安全。</li>
<li>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的</li>
<li>StringBuilder并没有对方法加了同步锁，所以是非线程安全的</li>
</ul>
<p><strong>性能</strong></p>
<ul>
<li>每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象</li>
<li>StringBuffer每次都会对对象本身进行操作，而不是生成新的对象并改变对象的引用，相同情况下，使用StringBuilder相比使用StringBuffer仅能获得10%~15%左右的性能提升，但却要冒多线程不安全的风险。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ul>
<h3 id="15：String为什么是不可变的？"><a href="#15：String为什么是不可变的？" class="headerlink" title="15：String为什么是不可变的？"></a>15：String为什么是不可变的？</h3><p>被final关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变,修饰的变量是引用类型则不能再指向其他对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>保存字符的数组被final修饰且为私有的，并且String类没有提供&#x2F;暴露修改这个字符串的方法。</li>
<li>String类被final修饰导致其不能被继承，进而避免了子类破坏String不可变。</li>
</ul>
<p>**Java9为何要将String的底层实现由char[]改为byte[]**：这是因为新版的String支持两个编码方案，Latin-1和UTF-16.如果字符串中包含的汉字没有超过Latin-1可表示范围内的字符，那就会使用Latin-1作为编码方案。Latin-1编码方案下，byte占一个字节(8位),char占用2个字节,byte相较于char节省一半的内存空间。</p>
<p>Latin-1编码范围为0-255，通常情况下，汉字通常使用Unicode字符集来表示的,对于一个字符是否可以被Latin-1表示，取决于该字符的Unicode码点是否在0-255之间。当字符串中包含的汉字没有超过Latin-1可表示范围内字符时，可以通过Latin-1编码表示。</p>
<h3 id="16：字符串的拼接用“-”还是StringBuilder"><a href="#16：字符串的拼接用“-”还是StringBuilder" class="headerlink" title="16：字符串的拼接用“+”还是StringBuilder"></a>16：字符串的拼接用“+”还是StringBuilder</h3><p>通过字节码可以看出字符串对象通过“+”的字符串拼接方式，实际上是通过StringBuilder调用append()方法实现的，拼接完成之后调用toString()后得到一个String对象。<strong>如果在循环内使用&#x3D;&#x3D;+&#x3D;&#x3D;进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个StringBuilder以复用，会导致创建过多的StringBuilder对象</strong>。但是如果直接使用StringBuilder对象进行字符串拼接的话，就不会出现这个问题。<strong>在JDK9之后</strong>字符串相加“+”改为了动态方法<code>makeConcatWithConstants()</code> 来实现，而不是大量的StringBuilder了。</p>
<h3 id="16：String中的equals-方法和Object中的equals-有何区别"><a href="#16：String中的equals-方法和Object中的equals-有何区别" class="headerlink" title="16：String中的equals()方法和Object中的equals()有何区别"></a>16：String中的equals()方法和Object中的equals()有何区别</h3><p>String中的equals()方法时被重写过的，比较的是String字符串的值是否相等。Object的方法是比较的对象的内存地址</p>
<p><strong>字符串常量池的作用</strong>：字符串常量池是JVM为了提升性能和减少内存消耗针对字符串专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="17-String-s-new-String-“abc”-这句话创建了几个字符串对象"><a href="#17-String-s-new-String-“abc”-这句话创建了几个字符串对象" class="headerlink" title="17:String s &#x3D; new String(“abc”)这句话创建了几个字符串对象"></a>17:String s &#x3D; new String(“abc”)这句话创建了几个字符串对象</h3><p>会创建1个对象或者2个字符串对象</p>
<ul>
<li>&#x3D;&#x3D;首先对于String s &#x3D; “abc”会先从字符串常量池中查找对应的引用，如果常量池中已经存在“abc”的引用，那么直接将s指向这个引用就可以了，如果常量池中不存在“abc”的引用，则在堆区new一个String对象，然后将“abc”的引用放入常量池中&#x3D;&#x3D;。</li>
<li>new String(“abc”)相当于new String(String s1 &#x3D; “abc”),即先要执行String s1 &#x3D; “abc”会创建0个或1个对象，然后在再堆区new一个String对象。因此String s &#x3D; new String(“abc”)创建了1个或者2个对象。</li>
</ul>
<p>创建两个对象的字节码</p>
<p><img src="C:\Users\Acer\AppData\Roaming\Typora\typora-user-images\image-20240107170205769.png" alt="image-20240107170205769" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>创建一个对象的字节码</p>
<p><img src="C:\Users\Acer\AppData\Roaming\Typora\typora-user-images\image-20240107170303112.png" alt="image-20240107170303112" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><code>ldc</code> 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。</p>
<h3 id="18：String中的intern方法有什么作用？"><a href="#18：String中的intern方法有什么作用？" class="headerlink" title="18：String中的intern方法有什么作用？"></a>18：String中的intern方法有什么作用？</h3><p>String.intern()是一个native方法，其作用是将指定的字符对象引用保存在字符串常量池中。</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，那直接返回该引用</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 会在堆中在单独创建一个字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>String类型的变量和常量做“+”运算时发生了什么？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于编译期可以确定的字符串，也就是常量字符串，JVM会将其存入字符串常量池中。并且字符串常量拼接得到的字符串常量在编译阶段就已经被存放盗字符串常量池，这个得益于编译器在编译过程中做的一个 <strong>常量折叠</strong>的代码优化。</p>
<p><strong>常量折叠</strong>:会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是Javac编译器会对源代码做的极少量优化措施之一（代码优化几乎都在即时编译器中进行）,&#x3D;&#x3D;对于String str3 &#x3D; “str” + “ing”；编译器会优化成String str3 &#x3D; “string”&#x3D;&#x3D;。以下几种数据类型会进行常量折叠</p>
<ul>
<li>基本数据类型以及字符串常量</li>
<li>final修饰的基本数据类型和字符串变量</li>
<li>通过“+”拼接字符串常量得到的字符串 <strong>如str3</strong>，节本数据类型之间算数运算，基本数据类型之间的位运算。</li>
</ul>
<p><strong>引用的值在程序编译期间无法确定，编译器无法对其优化</strong>,对象引用和“+”的字符串拼接方式，实际上是通过StringBuilder调用append()方法实现的，拼接完成之后调用toString()得到一个String对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str1).append(str2).toString();</span><br></pre></td></tr></table></figure>

<p><strong>注意：字符串在使用final关键字修饰后，可以让编译器当做常量来处理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果在编译运行时才能知道其确切值的话，就无法对其优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> getStr();<span class="comment">//在运行期间才能知道其确切值，无法直接将其直接存入常量池中。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 在堆上创建的新的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




</article>
    
    

</div>
<div id="post-next-prev" class="row">
    <div class="col-lg-12">
        <!-- title -->
        <h5 class="trm-title-with-divider">
            Other Articles
            <span data-number="02"></span>
        </h5>
    </div>
    
        <div class="col-lg-6">
    <div class="trm-blog-card trm-scroll-animation">
        <a href="/2024/01/18/java%E5%9F%BA%E7%A1%803/" class="trm-cover-frame trm-anima-link">
            
            
                <img alt="cover" class="no-fancybox" src="/img/block.jpg">
            
        </a>
        
        <div class="trm-card-descr">
            <div class="trm-label trm-category trm-mb-20">
                <a href=" #.">
                    Unclassified
                </a>
            </div>
            <h5>
                <a href="/2024/01/18/java%E5%9F%BA%E7%A1%803/" class="trm-anima-link">
                    
                </a>
            </h5>
            <div class="trm-divider trm-mb-20 trm-mt-20"></div>
            <ul class="trm-card-data trm-label">
                <li>24/01/18</li>
                <li>17:37</li>
                
                
            </ul>
        </div>
    </div>
</div>
    
    
</div>

    



                    <div class="trm-divider footer-divider"></div>

                    <!-- footer -->
                    <footer class="trm-scroll-animation">

    

    

    
        <div class="trm-footer-item">
            <span>
                Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v7.0.0
            </span>
            <span class="footer-separator" data-separator=" | "></span>
            <span> 
                Theme - 
                <a rel="noopener" href='https://github.com/MaLuns/hexo-theme-async' target='_blank'>Async</a>
                v2.1.0-beta.2
            </span>
        </div>
      

     

     
</footer>
 
                    <!-- footer end -->

                </div>
            </div>
        </div>
    </div>
</div>
            <!-- body end -->

            

            
<div class="trm-fixed-container">
    
        <div class="trm-fixed-btn post-toc-btn" data-title="Open toc">
            <i class="iconfont fas fa-th-list"></i>
        </div>
    
    
        <div class="trm-fixed-btn" data-title="Read Mode" onclick="asyncFun.switchReadMode()">
            <i class="iconfont fas fa-book-reader"></i>
        </div>
    
    
    <div id="trm-back-top" class="trm-fixed-btn" data-title="Back To Top">
        <i class="iconfont fas fa-arrow-up"></i>
    </div>
</div>
        </div>
      </div>
      <!-- scroll container end -->
  </div>
  <!-- app wrapper end -->

  
  <!-- Plugin -->




    
    
<script src="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script>

    

    

    

    <!-- 数学公式 -->
    

    <!-- 评论插件 -->
    
        

        
    



<!-- CDN -->


    

    

    




    <!-- Service Worker -->
    
    <!-- baidu push -->
    


<script id="async-script" src="/js/main.js?v=2.1.0-beta.2"></script>

</body>

</html>